use [Lab2]
go

/*

Для этих процедур достаточно чтобы обе они вызывались из-под одной транзакции с уровнем изоляции READ UNCOMMITTED.

Процедура sp_GetDoc просматривает очередь, при этом перед прочтением каждой записи на неё сначала делается попытка
наложить UPDATE-блокировку, в случае успеха если [StartProcessing] имеет значение NULL перед обновлением делается
попытка на запись наложить эксклюзивную блокировку. И в первом и во втором случае если на текущую запись уже наложены
несовместимые блокировки, она пропускается из-за подсказки оптимизатору WITH (READPAST), тем самым различные процессы
не будут мешать друг-другу выбирать документы из очереди. После обновления записи и до конца транзакции на ней будет
"висеть" эксклюзивная блокировка. После обновления записи будет произведено чтение документа, либо из отдельной страницы,
если не включена опция хранения полей NTEXT в строке, либо непосредственно из строки. После чтения сохранять блокировку
на текст документа не обязательно, так как для того, чтобы попытаться его изменить, другой транзакции необходимо будет
получить блокировку на запись, а на ней наша транзакция уже наложила несовместимую ни с чем эксклюзивную блокировку.
Наложить SHARED-блокировку для чтения документа из-под другой транзакции тоже не получится, так как текстовое поле либо
находится в заблокированной записи, если включена опция хранения полей NTEXT непосредственно в строке, либо на отдельной
странице, указатель на которую опять таки находится в заблокированной строчке.

Процедура sp_SetProcessed устанавливаем значения полей [Processed] и [ProcessedDate] записи, идентификатор которой был
в вызове sp_GetDoc. Если процедура вызывается из-под той-же транзакции, что и sp_GetDoc, то только из-под этой
транзакции можно будет изменять заблокированную эксклюзивно строчку.

*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_GetDoc]') AND type in (N'P', N'PC'))
  DROP PROCEDURE [dbo].[sp_GetDoc]
go

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_SetProcessed]') AND type in (N'P', N'PC'))
  DROP PROCEDURE [dbo].[sp_SetProcessed]
go

create procedure [dbo].[sp_GetDoc]
as

-- Если у таблицы [_BizTalkReceive] есть триггер, конструкцию OUTPUT ... INTO надо переделать
-- на запись в табличную переменную или временную таблицу, из которой потом выдавать данные.

update top(1) -- Возвращаем один документ. Можно сделать параметром процедуты.
  [_BizTalkReceive] with (readpast)
set
  [StartProcessing] = getdate()
output
  [inserted].[id]
 ,[inserted].[Doc]
where
  [StartProcessing] is null

go

create procedure [dbo].[sp_SetProcessed] (
  @docId int
)
as

update
  [_BizTalkReceive]
set
  [Processed] = 1
 ,[ProcessedDate] = getdate()
where
  [id] = @docId

go  
